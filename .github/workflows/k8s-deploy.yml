name: Deploy to GKE

on:
  push:
    branches: [main]
    paths:
      - 'k8s-manifests/**'
      - '.github/workflows/k8s-deploy.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: false
        type: choice
        options:
          - dev
          - prod
        default: 'dev'
      image_tag:
        description: 'Docker image tag'
        required: false
        default: 'latest'
  workflow_call:
    inputs:
      image_tag:
        required: true
        type: string

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || 'dev' }}
    steps:
      - uses: actions/checkout@v4

      - name: Load Config
        id: config
        run: |
          echo "project_id=$(grep 'project_id' terraform.tfvars | cut -d'=' -f2 | tr -d ' "')" >> $GITHUB_OUTPUT
          echo "region=$(grep 'region' terraform.tfvars | cut -d'=' -f2 | tr -d ' "')" >> $GITHUB_OUTPUT
          echo "cluster_name=$(grep 'cluster_name' terraform.tfvars | cut -d'=' -f2 | tr -d ' "')" >> $GITHUB_OUTPUT
          echo "repository_id=$(grep 'repository_id' terraform.tfvars | cut -d'=' -f2 | tr -d ' "')" >> $GITHUB_OUTPUT

      - uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ steps.config.outputs.cluster_name }}
          location: ${{ steps.config.outputs.region }}

      - name: Validate manifests
        run: |
          kubectl apply --dry-run=client -f k8s-manifests/

      - name: Create Namespaces
        run: |
          kubectl apply -f k8s-manifests/namespace-*.yaml

      - name: Deploy Security & Network Policies
        run: |
          kubectl apply -f k8s-manifests/security/
          kubectl apply -f k8s-manifests/network-policies/

      - name: Deploy Core Resources
        run: |
          find k8s-manifests/ -name '*.yaml' ! -name 'namespace-*.yaml' ! -path '*/security/*' ! -path '*/network-policies/*' ! -path '*/ingress/*' ! -path '*/monitoring/*' -exec kubectl apply -f {} \;

      - name: Set Image Tag
        id: set_tag
        run: |
          IMAGE_TAG="${{ inputs.image_tag || 'latest' }}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Using image tag: ${IMAGE_TAG}"

      - name: Update Image
        id: update_image
        run: |
          IMAGE="${{ steps.config.outputs.region }}-docker.pkg.dev/${{ steps.config.outputs.project_id }}/${{ steps.config.outputs.repository_id }}/app:${{ steps.set_tag.outputs.image_tag }}"
          kubectl set image deployment/app app=${IMAGE} || true
          kubectl set image deployment/app-critical -n prod app=${IMAGE} || true

      - name: Wait for Rollout
        id: rollout
        run: |
          kubectl rollout status deployment/app --timeout=5m
          kubectl rollout status deployment/app-critical -n prod --timeout=5m
        continue-on-error: true

      - name: Rollback on Failure
        if: steps.rollout.outcome == 'failure'
        run: |
          echo "Deployment failed, rolling back..."
          kubectl rollout undo deployment/app
          kubectl rollout undo deployment/app-critical -n prod
          exit 1

      - name: Deploy Monitoring & Ingress
        if: steps.rollout.outcome == 'success'
        run: |
          kubectl apply -f k8s-manifests/monitoring/ || true
          kubectl apply -f k8s-manifests/ingress/ || true

      - name: Verify deployment
        run: |
          echo "=== Pods Status ==="
          kubectl get pods -l app=myapp -o wide
          kubectl get pods -n prod -l app=myapp-critical -o wide
          
          echo "=== Services ==="
          kubectl get svc app-service
          
          echo "=== HPA Status ==="
          kubectl get hpa
          
          echo "=== PDB Status ==="
          kubectl get pdb --all-namespaces
          
          echo "=== Network Policies ==="
          kubectl get networkpolicies --all-namespaces

      - name: Run Health Checks
        run: |
          for pod in $(kubectl get pods -l app=myapp -o name); do
            kubectl exec $pod -- wget -q -O- http://localhost:8080/health || echo "Health check failed for $pod"
          done
